# Оптимизация производительности

**Статус:** Далёкое будущее (low priority)  
**Приоритет:** Низкий  
**Дата добавления:** 01.12.2025

---

## Текущее состояние

**Задержки при навигации:** ~70-140ms на папку

**Узкие места:**
1. `find` для поиска первого видеофайла: ~50-100ms
2. `extract_series_prefix/suffix` (regex): ~10-20ms
3. `db_get_series_settings` (SQLite): ~10-20ms

**Оценка:**
- ✅ Приемлемо для текущего использования
- ✅ SQLite не деградирует даже при 10K+ файлов
- ⚠️ Может стать заметным при очень больших коллекциях

---

## Предлагаемые оптимизации

### Фаза 1: Bash оптимизации (простые)

#### 1.1 Кэширование результатов `find`

**Проблема:**  
При каждом открытии папки вызывается `find` для поиска первого видеофайла

**Решение:**
```bash
# Глобальный кэш
declare -A VIDEO_FILE_CACHE

get_first_video_cached() {
    local dir="$1"
    if [ -z "${VIDEO_FILE_CACHE[$dir]}" ]; then
        VIDEO_FILE_CACHE[$dir]=$(find "$dir" -maxdepth 1 -type f \
            \( -name "*.mkv" -o -name "*.mp4" -o -name "*.avi" \) \
            2>/dev/null | head -1)
    fi
    echo "${VIDEO_FILE_CACHE[$dir]}"
}
```

**Ожидаемый эффект:**
- Первый вызов: ~100ms
- Повторные вызовы: ~1ms
- **Ускорение:** 50-100x для повторных обращений

#### 1.2 Кэширование настроек сериалов

**Проблема:**  
Запросы к БД при каждом рендеринге меню

**Решение:**
```bash
declare -A SETTINGS_CACHE

get_settings_cached() {
    local key="$1||$2"  # prefix||suffix
    if [ -z "${SETTINGS_CACHE[$key]}" ]; then
        SETTINGS_CACHE[$key]=$(db_get_series_settings "$1" "$2")
    fi
    echo "${SETTINGS_CACHE[$key]}"
}
```

**Ожидаемый эффект:**
- Уменьшение запросов к БД на 90%
- **Ускорение:** 10-20ms → <1ms

**Компромисс:**  
Нужна инвалидация кэша при изменении настроек

#### 1.3 Ленивая загрузка (lazy loading)

**Идея:**  
Не загружать настройки сразу для всех папок, только для текущей

**Реализация:**
- Показывать статус только для текущей открытой папки
- Не вызывать `get_settings_status_compact()` для подпапок

---

### Фаза 2: Гибридный подход (средняя сложность)

#### 2.1 Предварительная индексация

**Концепция:**
Создать фоновый процесс, который периодически сканирует коллекцию и кэширует метаданные

```bash
# background-indexer.sh
while true; do
    # Сканировать медиа директории
    # Обновлять кэш файлов
    # Обновлять индекс в БД
    sleep 300  # каждые 5 минут
done
```

**Преимущества:**
- Навигация мгновенная (всё уже в кэше)
- Автообновление при добавлении новых файлов

**Недостатки:**
- Дополнительная нагрузка на систему
- Сложность реализации

---

### Фаза 3: Нативная реализация (высокая сложность)

#### 3.1 Скомпилированная утилита на C

**Идея:**  
Критичные части (поиск файлов, парсинг, SQL) реализовать на C

**Архитектура:**
```
vlc-helper (C binary)
├── find_videos()      - замена find
├── parse_series()     - замена regex
└── db_query()         - прямые SQLite C API

serials.sh (bash)
└── вызывает vlc-helper
```

**Преимущества:**
- **10-100x ускорение** критичных операций
- Встроенный SQLite (как в VLC)
- Нет зависимостей

**Недостатки:**
- Нужна компиляция
- Сложность поддержки

**Пример:**
```c
// vlc-helper.c
#include <sqlite3.h>

int get_series_settings(const char* prefix, const char* suffix) {
    sqlite3* db;
    sqlite3_open("vlc_media.db", &db);
    // ... прямой SQL запрос через C API
    sqlite3_close(db);
}
```

---

## Измерение производительности

### Добавить debug timing

```bash
# В начале функции
DEBUG_TIMING=1
if [ "$DEBUG_TIMING" == "1" ]; then
    start=$(date +%s%N)
fi

# В конце функции
if [ "$DEBUG_TIMING" == "1" ]; then
    end=$(date +%s%N)
    ms=$((($end - $start) / 1000000))
    echo "[TIMING] $FUNCNAME: ${ms}ms" >> "$LOG_DIR/performance.log"
fi
```

### Бенчмарк скрипт

```bash
# benchmark.sh
for i in {1..100}; do
    time get_settings_status_compact "/path/to/series"
done | awk '{sum+=$1} END {print "Average:", sum/NR, "ms"}'
```

---

## Когда начинать оптимизацию?

**Критерии для начала Фазы 1:**
- ❌ Задержки > 300ms регулярно
- ❌ БД > 100 MB
- ❌ Пользовательские жалобы

**Критерии для Фазы 2:**
- ❌ Фаза 1 не помогла
- ❌ Коллекция > 50,000 файлов

**Критерии для Фазы 3:**
- ❌ Фаза 2 не помогла
- ❌ Задержки > 1 секунды

---

## Альтернативные решения

### A1: Упростить UI

**Вместо динамических статусов:**
- Показывать статус только по запросу (кнопка "Info")
- Убрать `get_settings_status_compact()` из меню

**Эффект:** Мгновенная навигация (нет запросов вообще)

### A2: Переписать на Python

**Плюсы:**
- Быстрее bash
- Встроенный SQLite модуль
- Проще кэширование

**Минусы:**
- Новая зависимость
- Больше кода

---

## Рекомендация

**На текущий момент:**
- ✅ Ничего не делать
- ✅ Продолжать использование как есть
- ✅ Мониторить производительность

**При появлении проблем:**
1. Сначала измерить (добавить timing)
2. Определить узкое место
3. Применить Фазу 1 (кэширование)
4. Только если не помогло - рассматривать Фазу 2/3

---

## Заметки

- SQLite производительность отличная до 100+ MB БД
- Bash задержки в основном от `find`, не от БД
- Raspberry Pi 4 справляется с текущей нагрузкой
- **Преждевременная оптимизация - корень всех зол** (Donald Knuth)
